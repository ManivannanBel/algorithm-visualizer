{"version":3,"sources":["components/Node/Node.jsx","Algorithms/Helper/minHeap.js","Algorithms/dijkstra.js","Algorithms/depthFirstSearch.js","Algorithms/breadthFirstSearch.js","Algorithms/bestFirstSearch.js","Algorithms/aStarSearch.js","Algorithms/bidirectionalSearch.js","components/VisualizerComponent.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","props","toggleVisited","ref","current","className","togglePath","toggleReset","toggleStart","toggleFinish","toggleWall","state","extraclassName","React","createRef","this","row","col","isStart","isFinish","isVisited","isWall","isPath","onMouseDown","onMouseEnter","onMouseUp","id","Component","MinHeap","elements","getLeftChildIndex","parentIndex","getRightChildIndex","getParentIndex","childIndex","Math","floor","hasLeftChild","heapNode","length","hasRightChild","hasParent","getLeftChildData","getRightChildData","getParentData","extractMin","shift","minValue","lastValue","pop","unshift","heapifyDown","getMin","insert","node","push","heapifyUp","index","smallerChildIndex","distance","currentData","smallestChildData","currentIndex","parent","isEmpty","element","dijkstra","grid","startNode","finishNode","visitedNodeOrder","unvisitedNodes","nodes","getAllNodes","sortUnvistedNodesByDistance","closestNode","console","log","Infinity","updateUnvisitedNeighbours","sort","nodeA","nodeB","unvisitedNeighbours","neighbours","filter","neighbour","getUnvisitedNeighbours","previousNode","hitEdge","getNeighbourNodes","getNeighbours","bestFirstSearch","gridRow","distanceFromTarget","abs","UpdateDistance","visitedNodesInOrder","minHeap","currentNode","updateNeighbours","hurestics","targetNode","huresticFunction","manhattanDistance","max","diagonalDistance","sqrt","pow","euclideanDistance","direction","isVisitedFromOther","START_POS_ROW","START_POS_COL","FINISH_POS_ROW","FINISH_POS_COL","VisualizerComponent","handleMouseClick","newGrid","removeWall","setState","buildWall","handleMouseDown","tempGrid","nodeRef","mousePressed","handleMouseEnter","handleMouseUp","newNode","createNode","hCost","gCost","fCost","nextNode","clearVisitedNode","resetStartNode","resetFinishNode","resetWallNode","resetVisitedNode","animateDijkstra","visitedNodeInOrder","shortestPath","i","setTimeout","printShortestPath","mousePointerEvents","visualizeDijkstra","slice","getShortestPath","animateDepthFirstSearch","DFSPath","visualizeDepthFirstSearch","visitedNodes","stack","neighbourNodes","depthFirstSearch","getDFSPath","animateBreadthFirstSearch","visualizeBreadthFirstSearch","queue","breadthFristSearch","BFSPath","getBFSPath","animateBestFirstSearch","GBFSPath","visualizeBestFirstSearch","getGBFSPath","animateAStarSearch","AStarPath","visualizeAStarSearch","openList","Heap","openSet","Set","closedSet","add","empty","delete","l","has","ng","updateItem","aStarSearch","aStarPath","getAStarPath","animateBidirectionalSearch","visualizeBidirectionalSearch","queue1","queue2","fromStart","fromFinish","finishNeighbours","startNeighbours","bidirectionalSearch","path","middle1","path1","path2","middle2","concat","getBidirectionalShortestPath","columnRow","rowRef","column","Navbar","bg","Brand","href","NavDropdown","title","style","pointerEvents","Item","onClick","Nav","Link","map","rowId","key","columnId","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.ac7d25a7.chunk.js","sourcesContent":["import React, { Component } from 'react'\r\nimport './Node.css'\r\n\r\nexport class Node extends Component {\r\n\r\n    constructor(props) {\r\n      super(props)\r\n      this.state = {\r\n        extraclassName : ''\r\n      }\r\n\r\n      this.ref = React.createRef()\r\n    }\r\n  \r\n    //Toggle node to visited\r\n    toggleVisited = () => {\r\n      this.ref.current.className = 'node visited-node'\r\n    }\r\n\r\n    togglePath = () => {\r\n      this.ref.current.className = 'node path-node'\r\n    }\r\n\r\n    toggleReset = () => {\r\n      this.ref.current.className = 'node '\r\n    }\r\n\r\n    toggleStart = () => {\r\n      this.ref.current.className = 'node start-node'\r\n    }\r\n\r\n    toggleFinish = () => {\r\n      this.ref.current.className = 'node finish-node'\r\n    }\r\n\r\n    toggleWall = () => {\r\n      this.ref.current.className = 'node wall-node'\r\n    }\r\n    \r\n\r\n    render() {\r\n        const {row, col, isStart, isFinish, isVisited, isWall, isPath, onMouseDown, onMouseEnter, onMouseUp} = this.props\r\n        //If current node is Start or target node then add additions css property to them\r\n        const extraclassName = (isPath)? 'path-node' : (isStart)? 'start-node' : (isFinish)? 'finish-node' : (isWall) ? 'wall-node':(isVisited) ? 'visited-node' : ''\r\n        //console.log(extraclassName)\r\n\r\n        return (\r\n          <div ref={this.ref}\r\n            id={`node-${row}-${col}`}\r\n            className={`node ${extraclassName}`}\r\n\r\n            onMouseDown={() => onMouseDown(row, col)}\r\n            onMouseEnter={() => onMouseEnter(row, col)}\r\n            onMouseUp={() => onMouseUp()}>\r\n           </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Node\r\n","export class MinHeap {\r\n    \r\n        constructor(elements) {\r\n           this.heapNode = [];\r\n           //console.log(this.heapNode)\r\n           for(let element of elements){\r\n               \r\n               this.insert(element)\r\n           }\r\n         }\r\n\r\n         getLeftChildIndex = parentIndex => {\r\n           return parentIndex * 2 + 1;\r\n         };\r\n\r\n         getRightChildIndex = parentIndex => {\r\n           return parentIndex * 2 + 2;\r\n         };\r\n\r\n         getParentIndex = childIndex => {\r\n           return Math.floor((childIndex - 1) / 2);\r\n         };\r\n\r\n         hasLeftChild = parentIndex => {\r\n           return this.getLeftChildIndex(parentIndex) < this.heapNode.length;\r\n         };\r\n\r\n         hasRightChild = parentIndex => {\r\n           return this.getRightChildIndex(parentIndex) < this.heapNode.length;\r\n         };\r\n\r\n         hasParent = childIndex => {\r\n           return this.getParentIndex(childIndex) >= 0;\r\n         };\r\n\r\n         getLeftChildData = parentIndex => {\r\n           return this.heapNode[this.getLeftChildIndex(parentIndex)];\r\n         };\r\n\r\n         getRightChildData = parentIndex => {\r\n           return this.heapNode[this.getRightChildIndex(parentIndex)];\r\n         };\r\n\r\n         getParentData = childIndex => {\r\n           return this.heapNode[this.getParentIndex(childIndex)];\r\n         };\r\n\r\n         extractMin = () => {\r\n            \r\n           if(this.heapNode.length === 1){\r\n               return this.heapNode.shift();\r\n           }\r\n           if (this.heapNode.length !== 0) {\r\n             const minValue = this.heapNode.shift();\r\n             const lastValue = this.heapNode.pop();\r\n             this.heapNode.unshift(lastValue);\r\n             this.heapifyDown();\r\n             return minValue;\r\n           }\r\n         };\r\n\r\n         getMin = () => {\r\n           if (this.heapNode.length !== 0) {\r\n             return this.heapNode[0];\r\n           }\r\n         };\r\n\r\n         insert = node => {\r\n           this.heapNode.push(node);\r\n           this.heapifyUp();\r\n         };\r\n\r\n         heapifyDown = () => {\r\n           let index = 0\r\n           while(this.hasLeftChild(index)){\r\n               let smallerChildIndex = this.getLeftChildIndex(index)\r\n               if(this.hasRightChild(index) && this.getLeftChildData(index).distance > this.getRightChildData(index).distance){\r\n                   smallerChildIndex = this.getRightChildIndex(index)\r\n               }\r\n\r\n               let currentData = (this.heapNode[index])\r\n               let smallestChildData = (this.heapNode[smallerChildIndex])\r\n\r\n               if(currentData.distance < smallestChildData.distance){\r\n                    break;\r\n               }else{\r\n                    this.heapNode[smallerChildIndex] = currentData\r\n                    this.heapNode[index] = smallestChildData\r\n               }\r\n               index = smallerChildIndex\r\n           }\r\n         };\r\n\r\n         heapifyUp = () => {\r\n           let currentIndex = this.heapNode.length - 1;\r\n           while (this.hasParent(currentIndex)) {\r\n             let parentIndex = this.getParentIndex(currentIndex);\r\n             let parent = (this.heapNode[parentIndex]);\r\n             let current = (this.heapNode[currentIndex]);\r\n             if (current.distance < parent.distance) {\r\n               this.heapNode[parentIndex] = current;\r\n               this.heapNode[currentIndex] = parent;\r\n               currentIndex = parentIndex;\r\n             } else {\r\n               break;\r\n             }\r\n           }\r\n         };\r\n\r\n         isEmpty = () => {\r\n            return this.heapNode.length === 0\r\n         }\r\n}\r\n","import {MinHeap} from './Helper/minHeap'\r\nconst heap = new MinHeap([])\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n    \r\n    if(!startNode || !finishNode || startNode === finishNode)\r\n        return false\r\n\r\n    const visitedNodeOrder = []\r\n    startNode.distance = 0\r\n    \r\n\r\n    /*heap.insert(startNode)\r\n    \r\n    while (!heap.isEmpty()) {\r\n        const closestNode = heap.extractMin()\r\n        if(closestNode.isVisited) continue\r\n        closestNode.isVisited = true;\r\n        //If the node is wall then ignore it\r\n        if(closestNode.isWall) continue\r\n        //If the start node is fully surrounded by wall\r\n        if(closestNode.distance === Infinity) return visitedNodeOrder\r\n        //If the node is visited then add it to the visited list\r\n        visitedNodeOrder.push(closestNode)\r\n        //If target node is found\r\n        if(closestNode === finishNode){\r\n            return visitedNodeOrder\r\n        }\r\n        //Update the distance and parent of the neighbouring nodes\r\n        updateUnvisitedNeighbours(closestNode, grid)\r\n    }*/\r\n    const unvisitedNodes = getAllNodes(grid)\r\n    while (unvisitedNodes.length !== 0) {\r\n        sortUnvistedNodesByDistance(unvisitedNodes)\r\n        const closestNode = unvisitedNodes.shift()\r\n        \r\n        //const closestNode = heap.extractMin()\r\n        console.log(closestNode)\r\n        \r\n        //If the start node is fully surrounded by wall\r\n        if(closestNode.distance === Infinity) return visitedNodeOrder\r\n\r\n        if(closestNode.isVisited) continue\r\n\r\n        closestNode.isVisited = true;\r\n        //If the node is wall then ignore it\r\n        if(closestNode.isWall) continue\r\n        \r\n        //If the node is visited then add it to the visited list\r\n        visitedNodeOrder.push(closestNode)\r\n        //If target node is found\r\n        if(closestNode === finishNode){\r\n            //heap.insert(visitedNodeOrder)\r\n            //console.log('min '+JSON.stringify(heap.extractMin()))\r\n            return visitedNodeOrder\r\n        }\r\n        //Update the distance and parent of the neighbouring nodes\r\n        updateUnvisitedNeighbours(closestNode, grid)\r\n    }\r\n}\r\n\r\nfunction sortUnvistedNodesByDistance(unvisitedNodes){\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\r\n}\r\n\r\nfunction updateUnvisitedNeighbours(node, grid){\r\n    const unvisitedNeighbours = getUnvisitedNeighbours(node, grid)\r\n    for(const neighbour of unvisitedNeighbours){\r\n        neighbour.distance = node.distance + 1\r\n        neighbour.previousNode = node\r\n        \r\n       // heap.insert(neighbour)\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid){\r\n    const  neighbours = []\r\n    const {row, col} = node\r\n    if(row > 0) neighbours.push(grid[row - 1][col])\r\n    if(row < grid.length - 1) neighbours.push(grid[row + 1][col])\r\n    if(col > 0) neighbours.push(grid[row][col - 1])\r\n    if(col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n\r\n    return neighbours.filter((neighbour) => (neighbour.isVisited === false))\r\n    /*console.log(neighbours.map((node) => console.log('['+node.row+\" \"+node.col+']'+' '+node.isVisited))+'neighbors of '+ node.row +\" \"+ node.col +\"= \")\r\n    return neighbours*/\r\n}\r\n\r\nfunction getAllNodes(grid){\r\n    const nodes = []\r\n    for(let row of grid){\r\n        for(let node of row){\r\n            nodes.push(node)\r\n        }\r\n    }\r\n    return nodes\r\n}\r\n\r\nexport function getShortestPath(finishNode){\r\n    const shortestPath = []\r\n     \r\n    //if there is no path\r\n     if(finishNode.previousNode === null)\r\n        return shortestPath\r\n\r\n    var currentNode = finishNode\r\n    while(currentNode != null){\r\n        currentNode = { ...currentNode, isPath : true}\r\n        shortestPath.unshift(currentNode);\r\n        currentNode = currentNode.previousNode\r\n    }\r\n    return shortestPath\r\n}","var hitEdge = false\r\nexport function depthFirstSearch(grid, startNode, finishNode){\r\n    \r\n    if(!startNode || !finishNode || startNode === finishNode)\r\n        return false\r\n\r\n    const visitedNodes = []\r\n    const stack = [startNode]\r\n    while(stack.length !== 0){\r\n        const currentNode = stack.pop()\r\n        if(currentNode.isWall) continue\r\n        if(currentNode.isVisited) continue\r\n        currentNode.isVisited = true\r\n        visitedNodes.push(currentNode)\r\n        if(currentNode === finishNode)\r\n            return visitedNodes\r\n        const neighbourNodes = getNeighbourNodes(grid, currentNode)\r\n        for(const neighbour of neighbourNodes){\r\n            neighbour.previousNode = currentNode\r\n            stack.push(neighbour)\r\n        }\r\n    }\r\n\r\n    //If target not found\r\n    return visitedNodes\r\n}\r\n\r\nfunction getNeighbourNodes(grid, node){\r\n    const neighbours = []\r\n    const {row, col} = node\r\n    \r\n    if(hitEdge){\r\n        if(row > 0) neighbours.push(grid[row - 1][col])\r\n        if(row < grid.length - 1) neighbours.push(grid[row + 1][col])\r\n        if(col > 0) neighbours.push(grid[row][col - 1])\r\n        if(col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n        else{\r\n            hitEdge = false\r\n        }\r\n    }else{\r\n        if(col > 0) neighbours.push(grid[row][col - 1])\r\n        if(col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n        if(row > 0) neighbours.push(grid[row - 1][col])\r\n        if(row < grid.length - 1) \r\n            neighbours.push(grid[row + 1][col])\r\n        else\r\n            hitEdge = true\r\n    }\r\n    return neighbours.filter(neighbour => !neighbour.isVisited)\r\n}\r\n\r\nexport function getDFSPath(finishNode){\r\n    const DFSPath = []\r\n    \r\n    //if there is no path\r\n    if(finishNode.previousNode === null)\r\n        return DFSPath\r\n\r\n    var currentNode = finishNode\r\n    while(currentNode !== null){\r\n        currentNode = { ...currentNode, isPath : true}\r\n        DFSPath.unshift(currentNode)\r\n        currentNode = currentNode.previousNode\r\n    }\r\n    return DFSPath\r\n}\r\n","\r\nexport function breadthFristSearch(grid, startNode, finishNode){\r\n\r\n    if(!startNode || !finishNode || startNode === finishNode)\r\n        return false\r\n\r\n    const visitedNodes = []\r\n    const queue = [startNode]\r\n    while(queue.length !== 0){\r\n        const currentNode = queue.shift()\r\n        if(currentNode.isWall) continue\r\n        if(currentNode.isVisited) continue\r\n        currentNode.isVisited = true\r\n        visitedNodes.push(currentNode)\r\n        if(currentNode === finishNode) return visitedNodes\r\n        const neighbours = getNeighbours(grid, currentNode)\r\n        for(const neighbour of neighbours){\r\n            neighbour.previousNode = currentNode\r\n            queue.push(neighbour)\r\n        }\r\n    }\r\n\r\n    //If target not found\r\n    return visitedNodes\r\n}\r\n\r\nfunction getNeighbours(grid, node){\r\n    const neighbours = []\r\n    const {row, col} = node\r\n    if(row > 0) neighbours.push(grid[row - 1][col])\r\n    if(row < grid.length - 1) neighbours.push(grid[row + 1][col])\r\n    if(col > 0) neighbours.push(grid[row][col - 1])\r\n    if(col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n\r\n    return neighbours.filter(neighbour => !neighbour.isVisited)\r\n}\r\n\r\nexport function getBFSPath(finishNode){\r\n    const BFSPath = []\r\n    \r\n    //if there is no path\r\n    if(finishNode.previousNode === null)\r\n        return BFSPath\r\n\r\n    var currentNode = finishNode\r\n    while(currentNode !== null){\r\n        currentNode = { ...currentNode, isPath : true}\r\n        BFSPath.unshift(currentNode)\r\n        currentNode = currentNode.previousNode\r\n    }\r\n    return BFSPath\r\n}\r\n","import {MinHeap} from './Helper/minHeap'\r\n\r\nexport function bestFirstSearch(grid, startNode, finishNode){\r\n\r\n    if(!startNode || !finishNode || startNode === finishNode)\r\n        return false\r\n    \r\n    UpdateDistance(grid, finishNode)\r\n    //finishNode = grid[finishNode.row][finishNode.col]\r\n    //console.log(grid)\r\n\r\n    const visitedNodesInOrder = []\r\n    //startNode.distance = 0\r\n    const minHeap = new MinHeap([])\r\n    minHeap.insert(startNode)\r\n    while(!minHeap.isEmpty()){\r\n        const currentNode = minHeap.extractMin()\r\n        if(currentNode.isWall) continue\r\n        if(currentNode.isVisited) continue\r\n        currentNode.isVisited = true\r\n        visitedNodesInOrder.push(currentNode)\r\n        if(currentNode === finishNode)\r\n            return visitedNodesInOrder\r\n        updateNeighbours(grid, currentNode, minHeap)\r\n    }\r\n    /*const priorityQueue = [startNode]\r\n    while(priorityQueue.length !== 0){\r\n        sortUnvistedNodesByDistance(priorityQueue)\r\n        const currentNode = priorityQueue.shift()\r\n        console.log(priorityQueue.length)\r\n        if(currentNode.isVisited) continue\r\n        currentNode.isVisited = true\r\n        visitedNodesInOrder.push(currentNode)\r\n        if(currentNode.row === finishNode.row && currentNode.col === finishNode.col){\r\n            console.log(currentNode)\r\n            console.log(finishNode)\r\n            return visitedNodesInOrder\r\n        }\r\n\r\n        const neighbours = getUnvisitedNeighbours(grid, currentNode)\r\n        for(const neighbour of neighbours){\r\n            neighbour.previousNode = currentNode\r\n            priorityQueue.push(neighbour)\r\n        }\r\n    }*/\r\n    return visitedNodesInOrder\r\n}\r\n\r\nfunction sortUnvistedNodesByDistance(unvisitedNodes){\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\r\n}\r\n\r\nfunction updateNeighbours(grid, node, minHeap){\r\n    const unvisitedNeighbours = getUnvisitedNeighbours(grid, node)\r\n    for(let neighbour of unvisitedNeighbours){\r\n        //neighbour.distance = node.distance + 1\r\n        neighbour.previousNode = node\r\n        minHeap.insert(neighbour)\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbours(grid, node){\r\n    const neighbours = []\r\n    const {row, col} = node\r\n\r\n    if(row > 0) neighbours.push(grid[row - 1][col])\r\n    if(row < grid.length - 1) neighbours.push(grid[row + 1][col])\r\n    if(col > 0) neighbours.push(grid[row][col - 1])\r\n    if(col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n   \r\n    return neighbours.filter(neighbour => !neighbour.isVisited)\r\n}\r\n\r\nfunction UpdateDistance (grid, finishNode){\r\n    const {row, col} = finishNode\r\n    for(let gridRow of grid){\r\n        for(let node of gridRow){\r\n            const distanceFromTarget = Math.abs(node.row - row) + Math.abs(node.col - col)\r\n            /*const newNode = {\r\n                ...node,\r\n                distance : distanceFromTarget\r\n            }*/\r\n            grid[node.row][node.col].distance = distanceFromTarget\r\n        }\r\n    }\r\n    return grid\r\n}\r\n\r\nfunction getAllNodes(grid){\r\n    const nodes = []\r\n    for(let row of grid){\r\n        for(let node of row){\r\n            nodes.push(node)\r\n        }\r\n    }\r\n    return nodes\r\n}\r\n\r\nexport function getGBFSPath(finishNode){\r\n    const GBFSPath = []\r\n    \r\n    //if there is no path\r\n    if(finishNode.previousNode === null)\r\n        return GBFSPath\r\n\r\n    var currentNode = finishNode\r\n    while(currentNode !== null){\r\n        currentNode = { ...currentNode, isPath : true}\r\n        GBFSPath.unshift(currentNode)\r\n        currentNode = currentNode.previousNode\r\n    }\r\n    return GBFSPath\r\n}\r\n","import {MinHeap} from './Helper/minHeap'\r\nimport Heap from 'heap'\r\n\r\nexport function aStarSearch(grid, startNode, finishNode){\r\n\r\n    if(!startNode || !finishNode || startNode === finishNode)\r\n        return false\r\n\r\n    let openList = new Heap(function(nodeA, nodeB) {\r\n        return nodeA.fCost - nodeB.fCost;\r\n    })\r\n\r\n    const visitedNodes = []\r\n    \r\n    const openSet = new Set()\r\n    const closedSet = new Set()\r\n\r\n    startNode.fCost = 0\r\n    startNode.gCost = 0\r\n\r\n    openList.push(startNode)\r\n    openSet.add(startNode)\r\n\r\n    while(!openList.empty()){\r\n\r\n        const currentNode = openList.pop()\r\n        openSet.delete(currentNode)\r\n        closedSet.add(currentNode)\r\n\r\n        visitedNodes.push(currentNode)\r\n\r\n        if(currentNode === finishNode){\r\n            return visitedNodes\r\n        }\r\n\r\n        const neighbours = getNeighbours(grid, currentNode)\r\n        for(let i = 0, l = neighbours.length; i < l ; ++i){\r\n            const neighbour = neighbours[i]\r\n            \r\n            if(closedSet.has(neighbour))\r\n                continue\r\n            \r\n            let ng = currentNode.gCost + 1\r\n\r\n            if(!openSet.has(neighbour) || ng < neighbour.gCost){\r\n                neighbour.gCost = ng\r\n                neighbour.hCost = hurestics(currentNode, neighbour, 'manhattan_distance')\r\n                neighbour.fCost = neighbour.gCost + neighbour.hCost\r\n                neighbour.previousNode = currentNode\r\n\r\n                if(!openSet.has(neighbour)){\r\n                    openList.push(neighbour)\r\n                    openSet.add(neighbour)\r\n                }else{\r\n                    openList.updateItem(neighbour)\r\n                }\r\n            }\r\n        }  \r\n    }\r\n\r\n}\r\n\r\nfunction getDistance(node, target){\r\n    return manhattanDistance(node, target)\r\n}\r\n\r\nfunction hurestics(node, targetNode, huresticFunction){\r\n    if(huresticFunction === 'manhattan_distance'){\r\n        return manhattanDistance(node, targetNode)\r\n    }else if(huresticFunction === 'diagonal_distance'){\r\n        return diagonalDistance(node, targetNode)\r\n    }else{\r\n        return euclideanDistance(node, targetNode)\r\n    }\r\n}\r\n\r\nfunction manhattanDistance(node, targetNode){\r\n    return Math.abs(node.row - targetNode.row) + Math.abs(node.col - targetNode.col)\r\n}\r\n\r\nfunction diagonalDistance(node, targetNode){\r\n    return Math.max(Math.abs(node.row - targetNode.row), Math.abs(node.col - targetNode.col))\r\n}\r\n\r\nfunction euclideanDistance(node, targetNode){\r\n    return Math.sqrt(Math.pow((node.row - targetNode.row), 2) + Math.pow((node.col - targetNode.col), 2))\r\n}\r\n\r\n\r\nfunction getNeighbours(grid, node){\r\n    const neighbours = []\r\n    const {row, col} = node\r\n\r\n    if(row > 0) neighbours.push(grid[row - 1][col])\r\n    if(row < grid.length - 1) neighbours.push(grid[row + 1][col])\r\n    if(col > 0) neighbours.push(grid[row][col - 1])\r\n    if(col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n    \r\n    return neighbours.filter(neighbour => !neighbour.isWall)\r\n}\r\n\r\nexport function getAStarPath(finishNode){\r\n    const aStarPath = []\r\n    \r\n    //if there is no path\r\n    if(finishNode.previousNode === null)\r\n        return aStarPath\r\n\r\n    var currentNode = finishNode\r\n    while(currentNode !== null){\r\n        currentNode = { ...currentNode, isPath : true}\r\n        aStarPath.unshift(currentNode)\r\n        currentNode = currentNode.previousNode\r\n    }\r\n    return aStarPath\r\n}\r\n\r\nfunction getAllNodes(grid){\r\n    const nodes = []\r\n    for(let row of grid){\r\n        for(let node of row){\r\n            nodes.push(node)\r\n        }\r\n    }\r\n    return nodes\r\n}","export function bidirectionalSearch(grid, startNode, finishNode) {\r\n    if(!startNode || !finishNode || startNode === finishNode)\r\n        return false\r\n\r\n    const visitedNodes = []\r\n    const queue1 = [startNode]\r\n    const queue2 = [finishNode]\r\n    while(queue1.length !== 0 && queue2.length !== 0){\r\n        const fromStart = queue1.shift()\r\n        const fromFinish = queue2.shift()\r\n        if(fromFinish.isVisited){\r\n            console.log(fromFinish)\r\n            visitedNodes.push(fromFinish)\r\n            return visitedNodes\r\n        }\r\n        if(fromStart.isVisitedFromOther){\r\n            console.log(fromStart)\r\n            visitedNodes.push(fromStart)\r\n            return visitedNodes\r\n        }\r\n        if(fromStart === fromFinish){\r\n            return visitedNodes\r\n        }\r\n\r\n        if(fromStart.isVisited && fromFinish.isVisitedFromOther) \r\n            continue\r\n        else if(fromStart.isVisited){\r\n            fromFinish.isVisitedFromOther = true;\r\n            visitedNodes.push(fromFinish)\r\n            const finishNeighbours = getNeighbours(grid, fromFinish, 'from_finish')\r\n            for(const neighbour of finishNeighbours){\r\n                neighbour.nextNode = fromFinish\r\n                queue2.push(neighbour)\r\n            }\r\n        }else if(fromFinish.isVisitedFromOther){\r\n            fromStart.isVisited = true\r\n            visitedNodes.push(fromStart)\r\n            const startNeighbours = getNeighbours(grid, fromStart, 'from_start')\r\n            for(const neighbour of startNeighbours){\r\n                neighbour.previousNode = fromStart\r\n                queue1.push(neighbour)\r\n            }\r\n        } else{\r\n            fromFinish.isVisitedFromOther = true\r\n            visitedNodes.push(fromFinish)\r\n            const finishNeighbours = getNeighbours(grid, fromFinish, 'from_finish')\r\n            for(const neighbour of finishNeighbours){\r\n                neighbour.nextNode = fromFinish\r\n                queue2.push(neighbour)\r\n            }\r\n            fromStart.isVisited = true\r\n            visitedNodes.push(fromStart)\r\n            const startNeighbours = getNeighbours(grid, fromStart, 'from_start')\r\n            for(const neighbour of startNeighbours){\r\n                neighbour.previousNode = fromStart\r\n                queue1.push(neighbour)\r\n            }\r\n        }\r\n\r\n    }\r\n    return visitedNodes\r\n}\r\n\r\nfunction getNeighbours(grid, node, direction){\r\n    const neighbours = []\r\n    const {row, col} = node\r\n    if(row > 0) neighbours.push(grid[row - 1][col])\r\n    if(row < grid.length - 1) neighbours.push(grid[row + 1][col])\r\n    if(col > 0) neighbours.push(grid[row][col - 1])\r\n    if(col < grid[0].length - 1) neighbours.push(grid[row][col + 1])\r\n\r\n    if(direction === 'from_start')\r\n        return neighbours.filter(neighbour => !neighbour.isVisited && !neighbour.isWall)\r\n    return neighbours.filter(neighbour => !neighbour.isVisitedFromOther && !neighbour.isWall)\r\n}\r\nexport function getBidirectionalShortestPath(middle1 , finishNode){\r\n    const pathList = []\r\n    const path1 = []\r\n    const path2 = []\r\n    let middle2 = middle1.nextNode\r\n    while(middle1 !== null){\r\n        middle1.isPath = true\r\n        path1.unshift(middle1)\r\n        middle1 = middle1.previousNode\r\n    }\r\n\r\n    while(middle2 !== null){\r\n        middle2.isPath = true\r\n        path2.push(middle2)\r\n        middle2 = middle2.nextNode\r\n    }\r\n\r\n    return path1.concat(path2)\r\n}","import React, { Component } from 'react'\r\nimport Node from './Node/Node'\r\nimport {dijkstra, getShortestPath} from '../Algorithms/dijkstra'\r\nimport {depthFirstSearch, getDFSPath} from '../Algorithms/depthFirstSearch'\r\nimport {breadthFristSearch, getBFSPath} from '../Algorithms/breadthFirstSearch'\r\nimport {bestFirstSearch, getGBFSPath} from '../Algorithms/bestFirstSearch'\r\nimport { aStarSearch, getAStarPath } from \"../Algorithms/aStarSearch\"\r\nimport { bidirectionalSearch, getBidirectionalShortestPath } from \"../Algorithms/bidirectionalSearch\";\r\n\r\nimport Nav from 'react-bootstrap/Nav'\r\nimport Navbar from 'react-bootstrap/Navbar'\r\nimport NavDropdown from 'react-bootstrap/NavDropdown'\r\n\r\nimport './VisualizerComponent.css'\r\nimport 'bootstrap/dist/css/bootstrap.min.css'\r\n\r\nconst START_POS_ROW = 10\r\nconst START_POS_COL = 7\r\nconst FINISH_POS_ROW = 10\r\nconst FINISH_POS_COL = 45\r\n\r\nexport class VisualizerComponent extends Component {\r\n\r\n    constructor(props) {\r\n        super(props)\r\n    \r\n        this.state = {\r\n             grid : [],\r\n             mousePressed : false,\r\n             mousePointerEvents : 'auto'\r\n        }\r\n        \r\n        //Refs for all the nodes\r\n        this.nodeRef = []\r\n    }\r\n\r\n      handleMouseClick = (row, col) => {\r\n        if(!this.state.grid[row][col].isWall){\r\n          const newGrid = this.buildWall(row, col)\r\n          this.setState({grid : newGrid})\r\n        }else{\r\n          const newGrid = this.removeWall(row, col)\r\n          this.setState({grid : newGrid})\r\n        }\r\n      }\r\n\r\n      handleMouseDown = (row, col) => {\r\n        console.log('mouse down')\r\n        //if(this.state.algorithmRunning) return\r\n        if(this.state.grid[row][col].isStart || this.state.grid[row][col].isFinish)\r\n          return \r\n        if(!this.state.grid[row][col].isWall){\r\n          const newGrid = this.buildWall(row, col)\r\n          this.tempGrid = newGrid\r\n          this.mousePressed = true\r\n          this.nodeRef[row][col].current.toggleWall()\r\n          //this.setState({/*grid : newGrid,*/ mousePressed : true})\r\n        }else{\r\n          const newGrid = this.removeWall(row, col)\r\n          this.tempGrid = newGrid\r\n          this.nodeRef[row][col].current.toggleReset()\r\n          //this.setState({grid : newGrid})\r\n        }\r\n      }\r\n\r\n      handleMouseEnter = (row, col) => {\r\n        console.log('mouse enter')\r\n        //if(this.state.algorithmRunning) return\r\n        if(this.state.grid[row][col].isStart || this.state.grid[row][col].isFinish)\r\n          return \r\n        if(this.mousePressed){\r\n          if(!this.state.grid[row][col].isWall){\r\n            const newGrid = this.buildWall(row, col)\r\n            this.tempGrid = newGrid\r\n            this.nodeRef[row][col].current.toggleWall()\r\n            //this.setState({grid : newGrid})\r\n          }else{\r\n            /*const newGrid = this.removeWall(row, col)\r\n            this.tempGrid = newGrid\r\n            this.nodeRef[row][col].current.toggleReset()*/\r\n            //this.setState({grid : newGrid})\r\n          }\r\n        }\r\n      }\r\n    \r\n      handleMouseUp = () => {\r\n        console.log('mouse up')\r\n        this.mousePressed = false\r\n        this.setState({grid : this.tempGrid/*, mousePressed : false*/})\r\n      }\r\n\r\n      buildWall = (row, col) => {\r\n        const newGrid = this.state.grid\r\n        const node = newGrid[row][col]\r\n        const newNode = {\r\n          ...node,\r\n          isWall : true\r\n        }\r\n        newGrid[row][col] = newNode\r\n        return newGrid\r\n      }\r\n\r\n      removeWall = (row, col) => {\r\n        const newGrid = this.state.grid\r\n        const node = newGrid[row][col]\r\n        const newNode = {\r\n          ...node,\r\n          isWall : false\r\n        }\r\n        newGrid[row][col] = newNode\r\n        return newGrid\r\n      }\r\n\r\n    componentDidMount() {\r\n        const grid = []\r\n        \r\n        for(let row = 0 ; row < 20 ; row++){\r\n            const columnRow = []\r\n            const rowRef = []\r\n            for(let column = 0 ; column < 50 ; column++){\r\n                columnRow.push(this.createNode(row, column))\r\n                rowRef.push(React.createRef())      \r\n            }\r\n            this.nodeRef.push(rowRef)\r\n            grid.push(columnRow)\r\n        }\r\n        this.setState({grid : grid})\r\n        //console.log(grid)\r\n    }\r\n\r\n    createNode = (row, col) => {\r\n        const newNode = {\r\n        row,\r\n        col,\r\n        isStart : row === START_POS_ROW && col === START_POS_COL,\r\n        isFinish : row ===  FINISH_POS_ROW && col === FINISH_POS_COL,\r\n        distance : Infinity,\r\n        hCost : null,\r\n        gCost : null,\r\n        fCost : null,\r\n        previousNode : null ,\r\n        nextNode : null,\r\n        isVisited : false,\r\n        isVisitedFromOther : false,\r\n        isWall : false,\r\n        isPath : false\r\n        }\r\n        return newNode\r\n    }\r\n\r\n    clearVisitedNode = (removeWall) => {\r\n      const newGrid = this.state.grid\r\n      for(const row of newGrid){\r\n        for(const node of row){\r\n          const {row, col} = node\r\n          if(node.isStart){\r\n            this.resetStartNode(row, col, newGrid, node)  \r\n          }else if(node.isFinish){\r\n            this.resetFinishNode(row, col, newGrid, node)\r\n          }else if(node.isWall){\r\n            this.resetWallNode(row, col, newGrid, node, removeWall)\r\n          }else{\r\n            this.resetVisitedNode(row, col, newGrid, node)            \r\n          } \r\n        }\r\n      }\r\n      this.setState({grid : newGrid})\r\n      console.log(this.state.grid)\r\n    }\r\n\r\n    resetStartNode = (row, col, grid, node) => {\r\n      const newNode = {\r\n        ...node,\r\n        isPath: false,\r\n        isVisited: false,\r\n        isVisitedFromOther : false,\r\n        previousNode: null,\r\n        nextNode : null,\r\n        distance : Infinity,\r\n        hCost : null,\r\n        gCost : null,\r\n        fCost : null,\r\n      }\r\n      grid[row][col] = newNode\r\n      this.nodeRef[node.row][node.col].current.toggleStart();\r\n    }\r\n\r\n    resetFinishNode = (row, col, grid, node) => {\r\n      const newNode = {\r\n        ...node,\r\n        isPath: false,\r\n        isVisited: false,\r\n        isVisitedFromOther : false,\r\n        previousNode: null,\r\n        nextNode : null,\r\n        distance : Infinity,\r\n        hCost : null,\r\n        gCost : null,\r\n        fCost : null,\r\n      }\r\n      grid[row][col] = newNode\r\n      this.nodeRef[node.row][node.col].current.toggleFinish();\r\n    }\r\n\r\n    resetWallNode = (row, col, grid, node, removeWall) => {\r\n      if(removeWall){\r\n        this.resetVisitedNode(row, col, grid, node)\r\n      }else{\r\n        const newNode = {\r\n          ...node,\r\n          isPath: false,\r\n          isVisited: false,\r\n          isVisitedFromOther : false,\r\n          previousNode: null,\r\n          nextNode : null,\r\n          isWall : true,\r\n          distance : Infinity,\r\n          hCost : null,\r\n        gCost : null,\r\n        fCost : null,\r\n        }\r\n        grid[row][col] = newNode\r\n      }\r\n    }\r\n\r\n    resetVisitedNode = (row, col, grid, node) => {\r\n      const newNode = {\r\n        ...node,\r\n        isPath: false,\r\n        isVisited: false,\r\n        isVisitedFromOther : false,\r\n        previousNode: null,\r\n        nextNode : null,\r\n        isWall : false,\r\n        distance : Infinity,\r\n        hCost : null,\r\n        gCost : null,\r\n        fCost : null,\r\n      }\r\n\r\n      grid[row][col] = newNode\r\n      this.nodeRef[node.row][node.col].current.toggleReset();\r\n    }\r\n\r\n    animateDijkstra = (visitedNodeInOrder, shortestPath) => {\r\n        const grid = this.state.grid\r\n        for(let i = 0; i < visitedNodeInOrder.length; i++){\r\n            grid[visitedNodeInOrder[i].row][visitedNodeInOrder[i].col] = visitedNodeInOrder[i]\r\n            if(i === visitedNodeInOrder.length - 1){\r\n              setTimeout(() => {\r\n                this.printShortestPath(shortestPath, grid)\r\n              }, 10 * i)\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodeInOrder[i]\r\n                this.nodeRef[node.row][node.col].current.toggleVisited();\r\n            }, 10 * i)\r\n        }\r\n    }\r\n\r\n    printShortestPath = (shortestPath, grid) => {\r\n      if(shortestPath.length === 0){\r\n        setTimeout(() => {\r\n          this.setState({mousePointerEvents : 'auto'})\r\n        }, 30)\r\n        return\r\n      }\r\n      for(let i = 0; i < shortestPath.length; i++){\r\n        setTimeout(() => {\r\n          const node = shortestPath[i]\r\n          //console.log(grid[node.row][node.col])\r\n          grid[node.row][node.col] = node\r\n          this.nodeRef[node.row][node.col].current.togglePath();\r\n          if(i === shortestPath.length - 1){\r\n            this.setState({grid : grid})\r\n            setTimeout(() => {\r\n              this.setState({mousePointerEvents : 'auto'})\r\n            }, 30 * i+1);\r\n          }\r\n        }, 30 * i)\r\n      }\r\n      //console.log(this.state.algorithmRunning)\r\n    }\r\n\r\n    visualizeDijkstra = () => {\r\n      //console.log(this.state.algorithmRunning)\r\n      this.setState({mousePointerEvents : 'none'})\r\n      //console.log(this.state.algorithmRunning)\r\n      this.clearVisitedNode(false)\r\n\r\n      setTimeout(() => {\r\n        const {grid} = this.state\r\n        const startNode = grid[START_POS_ROW][START_POS_COL]\r\n        const finishNode = grid[FINISH_POS_ROW][FINISH_POS_COL]\r\n        const visitedNodeInOrder = dijkstra(grid.slice(), startNode, finishNode)\r\n        if(!visitedNodeInOrder) return\r\n        const shortestPath = getShortestPath(finishNode)\r\n        this.animateDijkstra(visitedNodeInOrder, shortestPath)\r\n      }, 500);\r\n        \r\n    }\r\n\r\n    animateDepthFirstSearch = (visitedNodeInOrder, DFSPath) => {\r\n      const grid = this.state.grid\r\n      for(let i = 0; i < visitedNodeInOrder.length; i++){\r\n        grid[visitedNodeInOrder[i].row][visitedNodeInOrder[i].col] = visitedNodeInOrder[i]\r\n        if(i === visitedNodeInOrder.length - 1){\r\n          setTimeout(() => {\r\n            this.printShortestPath(DFSPath, grid)\r\n          }, i * 30)\r\n        }\r\n        setTimeout(() => {\r\n          const node = visitedNodeInOrder[i]\r\n          this.nodeRef[node.row][node.col].current.toggleVisited()\r\n        }, i * 30)\r\n      }\r\n    }\r\n\r\n    visualizeDepthFirstSearch = () => {\r\n        this.setState({mousePointerEvents : 'none'})\r\n        this.clearVisitedNode(false)\r\n\r\n        setTimeout(()=>{\r\n          const {grid} = this.state\r\n          //console.log(grid)\r\n          const startNode = grid[START_POS_ROW][START_POS_COL]\r\n          const finishNode = grid[FINISH_POS_ROW][FINISH_POS_COL]\r\n          //console.log(JSON.stringify(startNode)+\" \"+JSON.stringify(finishNode))\r\n          const visitedNodeInOrder = depthFirstSearch(grid.slice(), startNode, finishNode)\r\n          if(!visitedNodeInOrder) return\r\n          const DFSPath = getDFSPath(finishNode)\r\n          this.animateDepthFirstSearch(visitedNodeInOrder, DFSPath)  \r\n        },500)\r\n\r\n         \r\n    }\r\n\r\n    animateBreadthFirstSearch = (visitedNodeInOrder, DFSPath) => {\r\n      const grid = this.state.grid\r\n      for(let i = 0; i < visitedNodeInOrder.length; i++){\r\n        grid[visitedNodeInOrder[i].row][visitedNodeInOrder[i].col] = visitedNodeInOrder[i]\r\n        if(i === visitedNodeInOrder.length - 1){\r\n          setTimeout(() => {\r\n            this.printShortestPath(DFSPath, grid)\r\n          }, i * 30)\r\n        }\r\n        setTimeout(() => {\r\n          const node = visitedNodeInOrder[i]\r\n          this.nodeRef[node.row][node.col].current.toggleVisited()\r\n        }, i * 30)\r\n      }\r\n    }\r\n\r\n\r\n    visualizeBreadthFirstSearch = () => {\r\n      this.setState({mousePointerEvents : 'none'})\r\n      this.clearVisitedNode(false)\r\n\r\n      setTimeout(() => {\r\n        const {grid} = this.state\r\n        const startNode = grid[START_POS_ROW][START_POS_COL]\r\n        const finishNode = grid[FINISH_POS_ROW][FINISH_POS_COL]\r\n        console.log(grid)\r\n        const visitedNodeInOrder = breadthFristSearch(grid.slice(), startNode, finishNode)\r\n        if(!visitedNodeInOrder) return\r\n        //console.log(visitedNodeInOrder)\r\n        const BFSPath = getBFSPath(finishNode)\r\n        this.animateBreadthFirstSearch(visitedNodeInOrder, BFSPath)\r\n      }, 500)\r\n      \r\n    }\r\n\r\n    animateBestFirstSearch = (visitedNodeInOrder, GBFSPath) => {\r\n      const grid = this.state.grid\r\n      for(let i = 0; i < visitedNodeInOrder.length; i++){\r\n        grid[visitedNodeInOrder[i].row][visitedNodeInOrder[i].col] = visitedNodeInOrder[i]\r\n        if(i === visitedNodeInOrder.length - 1){\r\n          setTimeout(() => {\r\n            this.printShortestPath(GBFSPath, grid)\r\n          }, i * 30)\r\n        }\r\n        setTimeout(() => {\r\n          const node = visitedNodeInOrder[i]\r\n          this.nodeRef[node.row][node.col].current.toggleVisited()\r\n        }, i * 30)\r\n      }\r\n    }\r\n\r\n    visualizeBestFirstSearch = () => {\r\n      this.setState({mousePointerEvents : 'none'})\r\n      this.clearVisitedNode(false)\r\n      setTimeout(() => {\r\n        const {grid} = this.state\r\n        const startNode = grid[START_POS_ROW][START_POS_COL]\r\n        const finishNode = grid[FINISH_POS_ROW][FINISH_POS_COL]\r\n        //console.log(grid)\r\n        const visitedNodeInOrder = bestFirstSearch(grid.slice(), startNode, finishNode)\r\n        if(!visitedNodeInOrder) return\r\n        //console.log(visitedNodeInOrder)\r\n        const GBFSPath = getGBFSPath(finishNode)\r\n        //console.log(GBFSPath)\r\n        this.animateBestFirstSearch(visitedNodeInOrder, GBFSPath)\r\n      }, 500)   \r\n    }\r\n\r\n    animateAStarSearch = (visitedNodeInOrder, AStarPath) => {\r\n      const grid = this.state.grid\r\n      for(let i = 0; i < visitedNodeInOrder.length; i++){\r\n        grid[visitedNodeInOrder[i].row][visitedNodeInOrder[i].col] = visitedNodeInOrder[i]\r\n        if(i === visitedNodeInOrder.length - 1){\r\n          setTimeout(() => {\r\n            this.printShortestPath(AStarPath, grid)\r\n          }, i * 10)\r\n        }\r\n        setTimeout(() => {\r\n          const node = visitedNodeInOrder[i]\r\n          this.nodeRef[node.row][node.col].current.toggleVisited()\r\n        }, i * 10)\r\n      }\r\n    }\r\n\r\n    visualizeAStarSearch = () => {\r\n      this.setState({mousePointerEvents : 'none'})\r\n      this.clearVisitedNode(false)\r\n      setTimeout(() => {\r\n        const {grid} = this.state\r\n        console.log(grid)\r\n        const startNode = grid[START_POS_ROW][START_POS_COL]\r\n        const finishNode = grid[FINISH_POS_ROW][FINISH_POS_COL]\r\n        //console.log(grid)\r\n        const visitedNodeInOrder = aStarSearch(grid.slice(), startNode, finishNode)\r\n        if(!visitedNodeInOrder) return\r\n        //console.log(visitedNodeInOrder)\r\n        const AStarPath = getAStarPath(finishNode)\r\n        //console.log(GBFSPath)\r\n        this.animateAStarSearch(visitedNodeInOrder, AStarPath)\r\n      }, 500)\r\n        \r\n    }\r\n\r\n    animateBidirectionalSearch = (visitedNodeInOrder, GBFSPath) => {\r\n      const grid = this.state.grid\r\n      for(let i = 0; i < visitedNodeInOrder.length; i++){\r\n        grid[visitedNodeInOrder[i].row][visitedNodeInOrder[i].col] = visitedNodeInOrder[i]\r\n        if(i === visitedNodeInOrder.length - 1){\r\n          setTimeout(() => {\r\n            this.printShortestPath(GBFSPath, grid)\r\n          }, i * 15)\r\n        }\r\n        setTimeout(() => {\r\n          const node = visitedNodeInOrder[i]\r\n          this.nodeRef[node.row][node.col].current.toggleVisited()\r\n        }, i * 15)\r\n      }\r\n    }\r\n\r\n    visualizeBidirectionalSearch = () => {\r\n      this.setState({mousePointerEvents : 'none'})\r\n      this.clearVisitedNode(false)\r\n      setTimeout(() => {\r\n        const {grid} = this.state\r\n        const startNode = grid[START_POS_ROW][START_POS_COL]\r\n        const finishNode = grid[FINISH_POS_ROW][FINISH_POS_COL]\r\n        //console.log(grid)\r\n        const visitedNodeInOrder = bidirectionalSearch(grid.slice(), startNode, finishNode)\r\n        //console.log(visitedNodeInOrder.pop())\r\n        if(!visitedNodeInOrder) return\r\n        console.log(visitedNodeInOrder.length)\r\n        const middle1 = visitedNodeInOrder[visitedNodeInOrder.length - 1]\r\n        const path = getBidirectionalShortestPath(middle1, finishNode)\r\n        //console.log(middle1)\r\n        console.log(path)\r\n        this.animateBidirectionalSearch(visitedNodeInOrder, path)\r\n      }, 500)   \r\n    }\r\n\r\n    \r\n    render() {\r\n        const grid = this.state.grid\r\n        //console.log(grid)\r\n        //Building the grid with table and table data as Node component\r\n\r\n        \r\n\r\n        return (\r\n          <div className='container-fluid'>\r\n            <div>\r\n            <Navbar bg=\"light\">\r\n            <Navbar.Brand href=\"#\">Algorithm Visualizer</Navbar.Brand>\r\n            <NavDropdown title=\"Select Algorithm\" id=\"basic-nav-dropdown\" style={{ pointerEvents : this.state.mousePointerEvents }}>\r\n            <NavDropdown.Item href=\"\" onClick={() => this.visualizeDijkstra()}>Visualize Dijkstra</NavDropdown.Item>\r\n            <NavDropdown.Item href=\"\" onClick={() => this.visualizeDepthFirstSearch()}>Visualize Depth Fisrt Search</NavDropdown.Item>\r\n            <NavDropdown.Item href=\"\" onClick={() => this.visualizeBreadthFirstSearch()}>Visualize Breadth Fisrt Search</NavDropdown.Item>\r\n            <NavDropdown.Item href=\"\" onClick={() => this.visualizeBestFirstSearch()}>Visualize Best Fisrt Search</NavDropdown.Item>\r\n            <NavDropdown.Item href=\"\" onClick={() => this.visualizeAStarSearch()}>Visualize A* Search</NavDropdown.Item>\r\n            <NavDropdown.Item href=\"\" onClick={() => this.visualizeBidirectionalSearch()}>Visualize Bidirectional Search Search</NavDropdown.Item>\r\n            </NavDropdown>\r\n            <Nav.Link onClick={() => this.clearVisitedNode(true)} style={{ pointerEvents : this.state.mousePointerEvents }}>clear board</Nav.Link>\r\n            </Navbar>\r\n            </div>\r\n            <div className=\"grid\" style={{ pointerEvents : this.state.mousePointerEvents }}>\r\n              <table>\r\n                <tbody>\r\n                  {grid.map((row, rowId) => {\r\n                    return (\r\n                      <tr className=\"tr-height\" key={rowId}>\r\n                        {row.map((column, columnId) => (\r\n                          <td key={columnId}>\r\n                            <Node\r\n                              row = {column.row}\r\n                              col = {column.col}\r\n                              isStart={column.isStart}\r\n                              isFinish={column.isFinish}\r\n                              isWall={column.isWall}\r\n                              isPath={column.isPath}\r\n                              isVisited={column.isVisited}\r\n                              onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                              onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                              onMouseUp={() => this.handleMouseUp()}\r\n                              \r\n                              ref={this.nodeRef[column.row][column.col]}\r\n                            />\r\n                          </td>\r\n                        ))}\r\n                      </tr>\r\n                    );\r\n                  })}\r\n                </tbody>\r\n              </table>\r\n            </div>\r\n          </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default VisualizerComponent\r\n","import React from 'react';\nimport './App.css';\nimport Visualizer from './components/VisualizerComponent'\nimport 'bootstrap/dist/css/bootstrap.min.css'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Visualizer/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}